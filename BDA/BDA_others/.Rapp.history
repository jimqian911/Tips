setwd("/Users/tomoyasasaki/Google ドライブ/TMY/code_practice/BDA/BDA_others/")
require(Rcpp)#
require(RcppArmadillo)#
require(coda)#
#
y <- c(62, 60, 63, 59, #
       63, 67, 71, 64, 65, 66, #
       68, 66, 71, 67, 68, 68, #
       56, 62, 60, 61, 63, 64, 63, 59)#
g <- c(rep(1, 4), rep(2, 6), rep(3, 6), rep(4, 8))
Rcpp::sourceCpp("BDA_chapter11.cpp")
require(devtoo;s)
require(devtools)
install.packages("devtoo;s")
install.packages("devtools")
has_devel()
require(devtools)
has_devel()
evalCpp("1+1")
Rcpp::sourceCpp("BDA_chapter11.cpp")
y <- c(62, 60, 63, 59, #
       63, 67, 71, 64, 65, 66, #
       68, 66, 71, 67, 68, 68, #
       56, 62, 60, 61, 63, 64, 63, 59)#
g <- c(rep(1, 4), rep(2, 6), rep(3, 6), rep(4, 8))
g
## BDA ch.11#
## Hiroto Katsumata#
## May 15, 2017#
#
require(MASS)#
require(mvtnorm)#
require(tidyverse)#
#
## The Gibbs Sampler#
## Bibariate normal distribution#
#
bvn_gibbs <- function(y1 = 0, y2 = 0, rho = 0.8, iteration = 500, start = c(2.5, 2.5)) {#
	theta1 <- numeric(iteration + 1)#
	theta2 <- numeric(iteration + 1)#
	theta1[1] <- start[1]#
	theta2[1] <- start[2]#
	for(t in 2:(iteration + 1)){#
		theta1[t] <- rnorm(1, y1 + rho * (theta2[t - 1] - y2), 1 - rho^2)#
		theta2[t] <- rnorm(1, y2 + rho * (theta1[t] - y1), 1 - rho^2)#
	}#
	list(theta1 = theta1, theta2 = theta2, y1 = y1, y2 = y2, rho = rho, iteration = iteration, start = start)#
}#
#
result_bvn_gibbs <- bvn_gibbs()#
#
data.frame(theta1 = result_bvn_gibbs$theta1, theta2 = result_bvn_gibbs$theta2) %>%#
ggplot(., aes(x = theta1, y = theta2)) +#
	geom_point() +#
	scale_x_continuous(limits = c(-4, 4)) +#
	scale_y_continuous(limits = c(-4, 4))#
## The Metropolis algorithm#
## Bivariate unit normal density with normal jumping kernel#
Metropolis  <- function(theta_t_1, jump = 0.2^2) {#
	mut <- theta_t_1#
	I2 <- matrix(c(1, 0, 0, 1), nrow = 2, ncol = 2)#
	proposed <- mvrnorm(n = 1, mu = mut, Sigma = I2 * jump)#
	r <- dmvnorm(x = proposed, mean = c(0, 0), sigma = I2) / dmvnorm(x = mut, mean = c(0, 0), sigma = I2)#
	accepted <- (r > runif(1, 0, 1))#
	thetat <- ifelse(rep(accepted, 2), proposed, theta_t_1)#
	thetat#
}#
#
bvn_metro <- function(iteration = 500, start = c(2.5, 2.5), jump = 0.2^2) {#
	theta1 <- numeric(iteration + 1)#
	theta2 <- numeric(iteration + 1)#
	theta1[1] <- start[1]#
	theta2[1] <- start[2]#
	for(t in 2:(iteration + 1)){#
		result <- Metropolis(theta_t_1 = c(theta1[t - 1], theta2[t - 1]), jump = jump)#
		theta1[t] <- result[1]#
		theta2[t] <- result[2]#
	}#
	list(theta1 = theta1, theta2 = theta2, iteration = iteration, start = start)#
}#
#
result_bvn_metro <- bvn_metro()#
data.frame(theta1 = result_bvn_metro$theta1, theta2 = result_bvn_metro$theta2) %>%#
ggplot(., aes(x = theta1, y = theta2)) +#
	geom_point() +#
	scale_x_continuous(limits = c(-4, 4)) +#
	scale_y_continuous(limits = c(-4, 4))#
#
result_bvn_metro <- bvn_metro(jump = 0.8^2)#
data.frame(theta1 = result_bvn_metro$theta1, theta2 = result_bvn_metro$theta2) %>%#
ggplot(., aes(x = theta1, y = theta2)) +#
	geom_point() +#
	scale_x_continuous(limits = c(-4, 4)) +#
	scale_y_continuous(limits = c(-4, 4))
## BDA ch.11#
## Hiroto Katsumata#
## May 15, 2017#
#
require(MASS)#
require(mvtnorm)#
require(tidyverse)#
#
## The Gibbs Sampler#
## Bibariate normal distribution#
#
bvn_gibbs <- function(y1 = 0, y2 = 0, rho = 0.8, iteration = 500, start = c(2.5, 2.5)) {#
	theta1 <- numeric(iteration + 1)#
	theta2 <- numeric(iteration + 1)#
	theta1[1] <- start[1]#
	theta2[1] <- start[2]#
	for(t in 2:(iteration + 1)){#
		theta1[t] <- rnorm(1, y1 + rho * (theta2[t - 1] - y2), 1 - rho^2)#
		theta2[t] <- rnorm(1, y2 + rho * (theta1[t] - y1), 1 - rho^2)#
	}#
	list(theta1 = theta1, theta2 = theta2, y1 = y1, y2 = y2, rho = rho, iteration = iteration, start = start)#
}#
#
result_bvn_gibbs <- bvn_gibbs()#
#
data.frame(theta1 = result_bvn_gibbs$theta1, theta2 = result_bvn_gibbs$theta2) %>%#
ggplot(., aes(x = theta1, y = theta2)) +#
	geom_point() +#
	scale_x_continuous(limits = c(-4, 4)) +#
	scale_y_continuous(limits = c(-4, 4))
## BDA ch.11#
## Hiroto Katsumata#
## May 15, 2017#
#
require(MASS)#
require(mvtnorm)#
require(tidyverse)#
#
## The Gibbs Sampler#
## Bibariate normal distribution#
#
bvn_gibbs <- function(y1 = 0, y2 = 0, rho = 0.8, iteration = 500, start = c(2.5, 2.5)) {#
	theta1 <- numeric(iteration + 1)#
	theta2 <- numeric(iteration + 1)#
	theta1[1] <- start[1]#
	theta2[1] <- start[2]#
	for(t in 2:(iteration + 1)){#
		theta1[t] <- rnorm(1, y1 + rho * (theta2[t - 1] - y2), 1 - rho^2)#
		theta2[t] <- rnorm(1, y2 + rho * (theta1[t] - y1), 1 - rho^2)#
	}#
	list(theta1 = theta1, theta2 = theta2, y1 = y1, y2 = y2, rho = rho, iteration = iteration, start = start)#
}#
#
result_bvn_gibbs <- bvn_gibbs()#
#
data.frame(theta1 = result_bvn_gibbs$theta1, theta2 = result_bvn_gibbs$theta2) %>%#
ggplot(., aes(x = theta1, y = theta2)) +#
	geom_point() +#
	scale_x_continuous(limits = c(-4, 4)) +#
	scale_y_continuous(limits = c(-4, 4))
rho <- 0.8#
y1 <- 0#
y2 <- 0#
#
# 初期値の設定#
theta1 <- list(c(2.5), c(2.5), c(-2.5), c(-2.5))#
theta2 <- list(c(2.5), c(-2.5), c(2.5), c(-2.5))
i <- 1
j <- 1
theta1[[i]][j] <- rnorm(1, rho*(theta2[[i]][j-1] - y2), 1 - rho^2)
a <- c(1)
a[2] <- 2
a
a[4] <- 2
a
a <- list(0)
a
a[[5]] <- 10
a
pol_jump <- function(n_sims = 100, init = sample(1:7, size = 1)) {#
  ## Assume there exist 0th and 15th islands that are uninhabited#
  pop <- c(0, 1:7, 0)#
  ## the initial island#
  current <- init#
  ## make dataframe for saving results#
  res_df <- data.frame(time = 1:n_sims,#
                       visited = rep(NA, n_sims))#
  ## the current island#
  res_df$visited[1] <- current#
  ## simulation of moving#
  for (t in 2:n_sims){#
    proposed <- current + ifelse(rbinom(1, 1, prob = .5), 1, -1)#
    prob_move <- min(1, pop[proposed + 1] / pop[current + 1])#
    current <- ifelse(runif(1, 0, 1) < prob_move, proposed, current)#
    res_df$visited[t] <- current#
  }#
  return(res_df)#
}
res <- pol_jump(n_sims = 10000)#
#
# show result as line graph#
trace1 <- ggplot(res, aes(x = time, y = visited)) +#
  geom_line() + coord_flip() +#
  ylab("Island") + xlab("Time") +#
  ggtitle("Random Walk - Chain")#
print(trace1)
histogram1 <- ggplot(res[5001:10000,], #
                     aes(x = visited, y = ..density..)) + #
  geom_histogram(binwidth = 1) +#
  xlab("Island") + ylab("Frequency") +#
  ggtitle("Random Walk - Histogram")#
print(histogram1)
res <- pol_jump(n_sims = 1000000)#
#
# show result as line graph#
trace1 <- ggplot(res, aes(x = time, y = visited)) +#
  geom_line() + coord_flip() +#
  ylab("Island") + xlab("Time") +#
  ggtitle("Random Walk - Chain")#
print(trace1)
dim(res)
res <- pol_jump(n_sims = 100000)
histogram1 <- ggplot(res[5001:100000,], #
                     aes(x = visited, y = ..density..)) + #
  geom_histogram(binwidth = 1) +#
  xlab("Island") + ylab("Frequency") +#
  ggtitle("Random Walk - Histogram")
histogram1
