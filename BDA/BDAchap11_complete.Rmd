---
title: "BDA_chap11"
output: html_document
---
# Chap 11

```{r, message=FALSE}
rm(list = ls())
library(ggplot2)
library(tidyverse)
library(geoR)
set.seed(1)
```


## Gibbs sampling (1) bivariate normal (p. 277-)
```{r}
y1 <- 0
y2 <- 0
rho <- .8

SampleTheta <- function(y, v, theta){
  new <- rnorm(1, y + v * (theta - y), 1 - v^2)
  return(new)
}

n <- 500
```

#### Sampling Theta
```{r, message = FALSE}
databox <- replicate(4, data.frame(theta1 = rep(NA, 2*n+1), theta2 = rep(NA, 2*n+1) , pattern = rep(NA, 2*n+1)), simplify  = FALSE)

names(databox) <- paste0("databox", 1:4)
theta1 <- c(2.5, 2.5, -2.5, -2.5)
theta2 <- c(2.5, -2.5, 2.5, -2.5)
thetas <- matrix(c(theta1, theta2), 4)

# sampling
for (j in 1:4){
  data <- databox[[j]] # choose dataframe
  data[1, 1:2] <- thetas[j, ] # set the initial value
  data[,3] <- rep(j, 2 * n +1 ) # set pattern
  for (i in 1:n ){
    theta_old2 <- data[2*i-1,2]
    theta_new1 <- SampleTheta(y2, rho, theta_old2)
    data[2*i,1] <- theta_new1
    data[2*i,2] <- theta_old2
    theta_new2 <- SampleTheta(y1, rho, theta_new1)
    data[2*i+1, 2] <- theta_new2
    data[2*i+1, 1] <- theta_new1
  }
  databox[[j]] <- data
}
```

```{r}
datafull <- bind_rows(databox[[1]], databox[[2]], databox[[3]], databox[[4]])
datafull2 <- bind_rows(databox[[1]][701:1000,], databox[[2]][701:1000,], databox[[3]][701:1000,], databox[[4]][701:1000,])
datafull$pattern <- as.factor(datafull$pattern)
datafull2$pattern <- as.factor(datafull2$pattern)

```

#### Figure for each four start points
```{r}
p_first <- list(0)
for (i in 1:4){
  p_first[[i]] <- ggplot(databox[[i]][1:5,], aes(x = theta1, y = theta2)) + 
                      geom_path() +
                      geom_point() +
                      xlim(c(-4, 4)) + 
                      ylim(c(-4, 4))
  print(p_first[[i]])
}

```


#### Figure for aggregated data
```{r}
p_last <- list(0)
for (i in 1:4){
  p_last[[i]] <- ggplot(databox[[i]][402:501,], aes(x = theta1, y = theta2)) + 
                geom_path() +
                geom_point() +
                xlim(c(-4, 4)) + 
                ylim(c(-4, 4))
}
```


```{r} 
ggplot(datafull, aes(x = theta1, y = theta2)) + 
  geom_path(aes(color = pattern), alpha = .4) +
  geom_point(aes(color = pattern), alpha = .4) +
  xlim(c(-4, 4)) + 
  ylim(c(-4, 4))


ggplot(datafull2, aes(x = theta1, y = theta2)) + 
  geom_path(aes(color = pattern), alpha = .4) +
  geom_point(aes(color = pattern), alpha = .4) +
  xlim(c(-4, 4)) + 
  ylim(c(-4, 4))

```


## Hierarchical normal model (p. 288-)
#### Initial Setting
```{r}
databox2 <- list(0)
databox2[[1]] <- c(62, 60, 63, 59)
databox2[[2]] <- c(63, 67, 71, 64, 65, 66)
databox2[[3]] <- c(68, 66, 71, 67, 68, 68)
databox2[[4]] <- c(56, 62, 60, 61, 63, 64, 63, 59)

J <- length(databox2)
n <- length( c(databox2[[1]], databox2[[2]], databox2[[3]], databox2[[4]]))
```

#### Some useful functions
```{r}
# set functions
rInvGamma <- function (n, shape, scale = 1) {
  return(1/rgamma(n = n, shape = shape, rate = scale))
}

rInvChiSq <- function (n, nu) {
  return(rInvGamma(n, shape = nu / 2, scale = 1/2))
}

rScaledInvChiSq <- function (n, nu, tau2) {
  return(rInvGamma(n, shape = nu / 2, scale = (nu * tau2) / 2))
}

```


#### Functions for sampling (see p.289)
```{r}
# data must be list here
# faster!
SampleTheta2 <- function(data, mu, tau2, sigma2, J){
  theta_new_vector <- numeric(J)
  for (j in 1:J){
    n_j <- length(data[[j]]) # set the length of the observations for each group
    y_j <- data[[j]]
    theta_hat0 <- (1/tau2) * mu + (n_j/sigma2) * mean(y_j)
    v_hat <- 1/tau2 + n_j/sigma2
    theta_hat <- theta_hat0 / v_hat
    theta_new <- rnorm(1, theta_hat, sqrt(1/v_hat))
    theta_new_vector[j] <- theta_new
  }
  return(theta_new_vector)
}

# better one
# use sapply(databox2, mean)
SampleTheta3 <- function(data, mu, tau2, sigma2, J){
  theta_new_vector <- numeric(J)
  mean_y <- sapply(data, mean)
  for (j in 1:J){
    n_j <- length(data[[j]]) # set the length of the observations for each group
    theta_hat0 <- (1/tau2) * mu + (n_j/sigma2) * mean_y[j]
    v_hat <- 1/tau2 + n_j/sigma2
    theta_hat <- theta_hat0 / v_hat
    theta_new_vector[j] <- rnorm(1, theta_hat, sqrt(1/v_hat))
  }
  return(theta_new_vector)
}

```

```{r}
# nn <- 10000
# t <- proc.time()
# result <- data.frame(parameter1 = rep(NA, nn), parameter2 = rep(NA, nn), parameter3 = rep(NA, nn), parameter4 = rep(NA, nn))
# for (i in 1:nn){
#   result[i,] <-  SampleThetaMiss(databox2, mu0, 10, 30, J)
# }
# proc.time() - t

```



```{r}
# data must be list here
# theta must be vector of theta with length J
# this is more efficient
SampleMu <- function(data, theta, tau2, J){
  mu_new <- rnorm(1, mean(theta), sqrt(tau2/J) )
  return(mu_new)
}
```


```{r}
# data is list
# theta as vector with length J
SampleSigmaMiss <- function(data, theta, J, N){
  temp <- 0
  for (j in 1:J){
    n_j <- length(data[[j]])
    data_j <- data[[j]]
    temp_j <- 0
    theta_j <- theta[j]
    for (i in 1:n_j){
      temp_j <- temp + (data_j[i] - theta_j)^2 # you need temp_j + (data_j[i] - theta_j)^2
    }
    temp <- temp + temp_j 
  }
  sigma_hat_sq <- 1/N * temp # (11.15)
  #sigma_new <- 1/rgamma(1, shape = n/2, scale = 1/(n/2 * sigma_hat_sq)) 
  sigma_new <- rScaledInvChiSq(1, N, sigma_hat_sq)
  return(sigma_new)
  #return(temp)
  # draw scaled inverse chi-square of shape n and scale sigma_hat_sq from inverse gamma distribution
}

# faster, better
SampleSigma <- function(data, theta, J, N){
  temp <- 0
  for (j in 1:J){
    temp <- temp + sum( (data[[j]] - theta[j])^2 ) # you need to repair here
  }
  #sigma_new <- 1/rgamma(1, shape = n/2, scale = 1/(n/2 * sigma_hat_sq)) 
  sigma_new <- rScaledInvChiSq(1, N, 1/N * temp)
  return(sigma_new)
  #return(temp)
  # draw scaled inverse chi-square of shape n and scale sigma_hat_sq from inverse gamma distribution
}

# mean(1/rgamma(100, shape = v/2, scale = 1/(v/2 * s^2)))
# mean(rinvchisq(100, v, s^2))
```




```{r}
# better, faster
SampleTau <- function(data, theta, mu, J){
  tau_hat_sq <- 1/ (J-1) * sum( (theta - mu)^2 )
  #tau_new <- 1/rgamma(1, shape = (J-1)/2, scale = 1/( (J-1)/2 * tau_hat_sq))
  tau_new <- rScaledInvChiSq(1, J-1, tau_hat_sq)
  return(tau_new)
}

```

```{r}
# nn <- 100
# t <- proc.time()
# result <- data.frame(parameter = rep(NA, nn))
# for (i in 1:nn){
#   result[i,1] <-  SampleTau(databox2, theta0, mu0, J)
# }


```

#### Settings
```{r set initial value}
# set initial value for theta
theta0 <- c()
for (j in 1:J){
  theta0 <- c(theta0, sample(databox2[[j]], 1))
}

# set initial value for mu
mu0 <- mean(theta0)

# set initial value
theta_temp <- theta0
mu_temp <- mu0

# set number of iteration
iter <- 100

# databox for containing results
databox3 <- data.frame(theta1 = rep(NA, iter), theta2 = rep(NA, iter) , theta3 = rep(NA, iter), theta4 = rep(NA, iter), mu = rep(NA, iter), sigma = rep(NA, iter), tau = rep(NA, iter))

```

#### Sampling stage
```{r}
t <- proc.time()
for (i in 1:iter){
  tau_temp <- SampleTau(databox2, theta_temp, mu_temp, J)
  databox3["tau"][i,] <- sqrt(tau_temp)
  sigma_temp <- SampleSigma(databox2, theta_temp, J, n)
  databox3["sigma"][i,] <- sqrt(sigma_temp)
  mu_temp <- SampleMu(databox2, theta_temp, tau_temp, J)
  databox3["mu"][i,] <- mu_temp
  theta_temp <- SampleTheta2(databox2, mu_temp, tau_temp, sigma_temp, J)
  databox3[i, 1:J] <- theta_temp
}
print(proc.time() - t)
print(summary(databox3))
```


